// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//! USER
enum Role {
  admin
  user
}

enum SaasPlan {
  FREE
  PRO
  BUSINESS
}

enum SaasPlanStatus {
  ACTIVE
  EXPIRED
  CANCELED
  TRIAL
}

// Le user est le SALON
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  password      String
  firstName     String?
  lastName      String?
  salonName     String?
  image         String?
  phone         String?
  address       String?
  city          String?
  postalCode    String?
  instagram     String?
  website       String?
  facebook      String?
  tiktok        String?
  description   String?
  salonHours    String?
  salonPhotos   String[]

  prestations   String[]
  addConfirmationEnabled Boolean   @default(false)
  appointmentBookingEnabled Boolean   @default(false)   // variable pour la prise de rendez-vous pour le salon ou par tatoueur

  saasPlan      SaasPlan  @default(FREE)
  saasPlanUntil DateTime? // Date jusqu'√† laquelle le plan est actif

  role          Role      @default(user)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  appointments Appointment[]
  Tatoueur     Tatoueur[]
  Client       Client[]

  TimeSlot TimeSlot[]

  Portfolio Portfolio[]

  ProductSalon ProductSalon[]

  FollowUpRequest    FollowUpRequest[]
  FollowUpSubmission FollowUpSubmission[]
  
  // Cr√©neaux bloqu√©s du salon
  blockedTimeSlots BlockedTimeSlot[]
  
  // Relation avec les d√©tails du plan SaaS
  saasPlanDetails SaasPlanDetails?

  AppointmentRequest AppointmentRequest[]
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token], name: "email_token")
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token], name: "email_token")
}

//! SALON
model Tatoueur {
  id          String   @id @default(cuid())
  name        String
  hours       String?
  user        User     @relation(fields: [userId], references: [id])
  userId      String // salon qui poss√®de ce tatoueur
  img         String?
  description String?
  phone       String?
  instagram   String?

  style       String[]
  skills      String[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  appointments Appointment[]

  Portfolio Portfolio[]
  
  // Cr√©neaux bloqu√©s pour ce tatoueur
  blockedTimeSlots BlockedTimeSlot[]
  
  // Demandes de reprogrammation o√π ce tatoueur est le nouveau tatoueur
  rescheduleRequests RescheduleRequest[]
}

//! CR√âNEAUX BLOQU√âS (VACANCES, CONG√âS, ETC.)
model BlockedTimeSlot {
  id String @id @default(cuid())
  
  // Dates et heures du blocage
  startDate DateTime
  endDate   DateTime
  
  // Raison du blocage (optionnel)
  reason String?
  
  // Tatoueur concern√© (optionnel - si null, bloque pour tous les tatoueurs du salon)
  tatoueurId String?
  tatoueur   Tatoueur? @relation(fields: [tatoueurId], references: [id], onDelete: Cascade)
  
  // Salon propri√©taire du blocage
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // M√©tadonn√©es
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([startDate, endDate])
  @@index([tatoueurId])
  @@index([userId])
}

//! AGENDA ET RDV
enum PrestationType {
  TATTOO
  PIERCING
  RETOUCHE
  PROJET
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  DECLINED
  CANCELED
  RESCHEDULING
  NO_SHOW
  COMPLETED
}

model Appointment {
  id         String            @id @default(cuid())
  title      String
  prestation PrestationType
  start      DateTime
  end        DateTime
  allDay     Boolean           @default(false)
  status     AppointmentStatus @default(PENDING)
  isPayed    Boolean           @default(false)

  // Relation avec User (nouvelle relation)
  user   User   @relation(fields: [userId], references: [id])
  userId String // ID du salon propri√©taire du rendez-vous

  tatoueur   Tatoueur? @relation(fields: [tatoueurId], references: [id])
  tatoueurId String?

  client   Client? @relation(fields: [clientId], references: [id])
  clientId String?

  //  Lien direct vers un TattooDetail pour les projets
  tattooDetail   TattooDetail?
  tattooDetailId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  TimeSlot TimeSlot[]

  FollowUpRequest FollowUpRequest[]

  FollowUpSubmission FollowUpSubmission[]
  
  rescheduleRequests RescheduleRequest[]
}

model AppointmentRequest {
  id            String   @id @default(cuid())
  userId        String   // Salon concern√©
  prestation    PrestationType
  clientFirstname    String
  clientLastname    String
  clientEmail   String
  clientPhone   String?
  clientBirthDate DateTime?
  availability  String   // Texte ou JSON selon ton front
  details       String?  // Zone, taille, style, etc. (JSON ou texte)
  message       String?  // Message libre du client
  status        String   @default("PENDING") // PENDING, PROPOSED, ACCEPTED, DECLINED, CLOTURED
  
  proposedDate  DateTime?
  proposedFrom  DateTime?
  proposedTo    DateTime?
  tatoueurId    String?

  token         String?         @unique
  tokenExpiresAt   DateTime?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  slots            ProposedSlot[] // <-- nouveau : 1-N propositions

  user          User     @relation(fields: [userId], references: [id])
}

model ProposedSlot {
  id                   String   @id @default(cuid())
  appointmentRequestId String
  from                 DateTime
  to                   DateTime
  tatoueurId           String?
  status               String   @default("PENDING") // PENDING, ACCEPTED, DECLINED, EXPIRED
  selectedAt           DateTime?
  createdAt            DateTime @default(now())

  appointmentRequest   AppointmentRequest @relation(fields: [appointmentRequestId], references: [id])

  @@index([appointmentRequestId])
}

model TimeSlot {
  id          String   @id @default(cuid())
  date        DateTime // Date du cr√©neau
  startTime   DateTime // Heure de d√©but du cr√©neau
  endTime     DateTime // Heure de fin du cr√©neau
  isAvailable Boolean  @default(true)

  userId String
  user   User   @relation(fields: [userId], references: [id])

  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  appointmentId String? // Li√© si ce cr√©neau a √©t√© r√©serv√©

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//! CLIENT & FICHE CLIENT
model Client {
  id     String @id @default(cuid())
  userId String // Salon propri√©taire de la fiche client
  user   User   @relation(fields: [userId], references: [id])

  firstName String
  lastName  String
  email     String
  phone     String
  birthDate DateTime?
  address   String?

  // Lien vers les RDV (facultatif)
  appointments Appointment[] // üëà Un client peut avoir plusieurs RDV

  // Relations
  tattooDetails    TattooDetail[] // üëà Un client peut avoir plusieurs d√©tails de tatouage
  medicalHistory   MedicalHistory?
  tattooHistory    TattooHistory[]
  aftercareRecords Aftercare[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  FollowUpSubmission FollowUpSubmission[]

  @@unique([userId, email])
}

model TattooDetail {
  id String @id @default(cuid())

  // Soit li√© √† un client
  clientId String?
  client   Client? @relation(fields: [clientId], references: [id])

  // Soit li√© √† un rendez-vous
  appointmentId String?      @unique
  appointment   Appointment? @relation(fields: [appointmentId], references: [id])

  description    String
  zone           String?
  size           String?
  colorStyle     String? // Noir & gris ou Couleur
  reference      String? // URL image du client
  sketch         String? // URL du croquis
  estimatedPrice Float?
  price          Float?
  isPayed        Boolean @default(false)
}

model MedicalHistory {
  id       String @id @default(cuid())
  clientId String @unique
  client   Client @relation(fields: [clientId], references: [id])

  allergies     String?
  healthIssues  String?
  medications   String?
  pregnancy     Boolean
  tattooHistory String? // Commentaire sur anciens tatouages
}

model TattooHistory {
  id       String @id @default(cuid())
  clientId String
  client   Client @relation(fields: [clientId], references: [id])

  date         DateTime
  description  String
  beforeImage  String? // URL
  afterImage   String? // URL
  inkUsed      String?
  healingTime  String?
  careProducts String?
}

model Aftercare {
  id       String @id @default(cuid())
  clientId String
  client   Client @relation(fields: [clientId], references: [id])

  submittedAt        DateTime @default(now())
  photoUrl           String?
  comment            String?
  approved           Boolean  @default(false)
  visibleInPortfolio Boolean  @default(false)
}

//! PORTFOLIO & PRODUITS
model Portfolio {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  title       String
  description String?
  imageUrl    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Lien vers les tatoueurs si n√©cessaire
  tatoueurId String?
  tatoueur   Tatoueur? @relation(fields: [tatoueurId], references: [id])
}

model ProductSalon {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  name        String
  description String?
  price       Float
  imageUrl    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// //! SALON SETTINGS
// model SalonSettings {
//   id                      String   @id @default(cuid())
//   salonName               String
//   autoConfirmationEnabled Boolean  @default(false)
//   createdAt               DateTime @default(now())
// }

// ----------------------
// SUIVI POST-RDV
// ----------------------
enum FollowUpStatus {
  PENDING
  SUBMITTED
  EXPIRED
}

model FollowUpRequest {
  id            String         @id @default(cuid())
  appointmentId String         @unique
  token         String         @unique
  status        FollowUpStatus @default(PENDING)
  sentAt        DateTime?
  expiresAt     DateTime?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  submissionId  String?        @unique
  userId        String         // Salon propri√©taire

  appointment  Appointment         @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  submission   FollowUpSubmission? @relation(fields: [submissionId], references: [id])
  user         User                @relation(fields: [userId], references: [id])

  @@index([status])
  @@index([createdAt])
  @@index([userId])
}

model FollowUpSubmission {
  id            String   @id @default(cuid())
  appointmentId String   @unique
  clientId      String?
  rating        Int
  review        String?
  photoUrl      String
  isAnswered    Boolean @default(false)
  response      String?
  isPhotoPublic Boolean @default(false)
  createdAt     DateTime @default(now())
  userId        String   // Salon propri√©taire

  appointment     Appointment      @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  client          Client?          @relation(fields: [clientId], references: [id])
  followUpRequest FollowUpRequest?
  user            User             @relation(fields: [userId], references: [id])

  @@index([createdAt])
  @@index([userId])
}

// ----------------------
// D√âTAILS PLAN SAAS
// ----------------------
model SaasPlanDetails {
  id     String @id @default(cuid())
  userId String @unique

  // Plan actuel
  currentPlan   SaasPlan       @default(FREE)
  planStatus    SaasPlanStatus @default(ACTIVE)
  startDate     DateTime       @default(now())
  endDate       DateTime? // Null = illimit√©
  trialEndDate  DateTime? // Date fin d'essai
  
  // Limites du plan (FREE par d√©faut)
  maxAppointments    Int  @default(30)   // FREE: 30, PRO: 150, BUSINESS: -1 (illimit√©)
  maxClients         Int  @default(50)   // FREE: 50, PRO: 300, BUSINESS: -1 (illimit√©)
  maxTattooeurs      Int  @default(1)    // FREE: 1, PRO: 5, BUSINESS: -1 (illimit√©)
  maxPortfolioImages Int  @default(5)    // FREE: 5, PRO: 50, BUSINESS: -1 (illimit√©)

  // Fonctionnalit√©s
  hasAdvancedStats   Boolean @default(false) // Statistiques avanc√©es
  hasEmailReminders  Boolean @default(false) // Rappels email
  hasCustomBranding  Boolean @default(false) // Marque personnalis√©e
  hasApiAccess       Boolean @default(false) // Acc√®s API
  
  // Facturation
  monthlyPrice       Float?   // Prix mensuel
  yearlyPrice        Float?   // Prix annuel
  lastPaymentDate    DateTime?
  nextPaymentDate    DateTime?
  paymentMethod      String?  // 'stripe', 'paypal', etc.
  stripeCustomerId   String?  // ID client Stripe
  
  // M√©tadonn√©es
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([currentPlan])
  @@index([planStatus])
  @@index([endDate])
}

//! RESCHEDULE REQUEST
enum RescheduleStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}

model RescheduleRequest {
  id               String           @id @default(cuid())
  appointmentId    String
  token            String           @unique
  reason           String?
  newTatoueurId    String?
  status           RescheduleStatus @default(PENDING)
  clientMessage    String?
  expiresAt        DateTime
  processedAt      DateTime?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  appointment      Appointment      @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  newTatoueur      Tatoueur?        @relation(fields: [newTatoueurId], references: [id], onDelete: SetNull)

  @@index([token])
  @@index([appointmentId])
  @@index([status])
  @@index([expiresAt])
}
