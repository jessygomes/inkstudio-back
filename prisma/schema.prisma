generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        String               @id @default(cuid())
  email                     String               @unique
  emailVerified             DateTime?
  password                  String
  firstName                 String?
  lastName                  String?
  salonName                 String?
  image                     String?
  phone                     String?
  address                   String?
  city                      String?
  postalCode                String?
  instagram                 String?
  website                   String?
  facebook                  String?
  tiktok                    String?
  description               String?
  salonHours                String?
  salonPhotos               String[]

  saasPlan                  SaasPlan             @default(FREE)
  saasPlanUntil             DateTime?

  role                      Role                 @default(user)

  createdAt                 DateTime             @default(now())
  updatedAt                 DateTime             @updatedAt

  prestations               String[]

  addConfirmationEnabled    Boolean              @default(false)
  appointmentBookingEnabled Boolean              @default(false)

  colorProfile              String?              @default("default")
  colorProfileBis           String?              @default("default")

  appointments              Appointment[]
  AppointmentRequest        AppointmentRequest[]
  blockedTimeSlots          BlockedTimeSlot[]

  Client                    Client[]
  FollowUpRequest           FollowUpRequest[]
  FollowUpSubmission        FollowUpSubmission[]

  Portfolio                 Portfolio[]
  ProductSalon              ProductSalon[]

  saasPlanDetails           SaasPlanDetails?
  
  Tatoueur                  Tatoueur[]
  TimeSlot                  TimeSlot[]

  StockItem                  StockItem[]
  PiercingPrice             PiercingPrice[]
  PiercingServicePrice      PiercingServicePrice[]
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token], name: "email_token")
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token], name: "email_token")
}

model Tatoueur {
  id                 String              @id @default(cuid())
  name               String
  hours              String?
  userId             String
  img                String?
  description        String?
  phone              String?
  instagram          String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  skills             String[]
  style              String[]
  rdvBookingEnabled  Boolean             @default(true)
  appointments       Appointment[]
  blockedTimeSlots   BlockedTimeSlot[]
  Portfolio          Portfolio[]
  rescheduleRequests RescheduleRequest[]
  user               User                @relation(fields: [userId], references: [id])
  TattooHistory      TattooHistory[]
}

model BlockedTimeSlot {
  id         String    @id @default(cuid())
  startDate  DateTime
  endDate    DateTime
  reason     String?
  tatoueurId String?
  userId     String
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  tatoueur   Tatoueur? @relation(fields: [tatoueurId], references: [id], onDelete: Cascade)
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([startDate, endDate])
  @@index([tatoueurId])
  @@index([userId])
}

model Appointment {
  id                 String              @id @default(cuid())
  title              String
  prestation         PrestationType
  start              DateTime
  end                DateTime
  allDay             Boolean             @default(false)
  status             AppointmentStatus   @default(PENDING)
  isPayed            Boolean             @default(false)
  userId             String
  tatoueurId         String?
  clientId           String?
  tattooDetailId     String?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt
  visio              Boolean             @default(false)
  visioRoom          String?
  client             Client?             @relation(fields: [clientId], references: [id])
  tatoueur           Tatoueur?           @relation(fields: [tatoueurId], references: [id])
  user               User                @relation(fields: [userId], references: [id])
  FollowUpRequest    FollowUpRequest?
  FollowUpSubmission FollowUpSubmission?
  rescheduleRequests RescheduleRequest[]
  tattooDetail       TattooDetail?
  TimeSlot           TimeSlot[]
}

model AppointmentRequest {
  id              String         @id @default(cuid())
  userId          String
  prestation      PrestationType
  clientFirstname String
  clientLastname  String
  clientEmail     String
  clientPhone     String?
  clientBirthDate DateTime?
  availability    String
  details         String?
  message         String?
  status          String         @default("PENDING")
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt
  proposedDate    DateTime?
  proposedFrom    DateTime?
  proposedTo      DateTime?
  tatoueurId      String?
  token           String?        @unique
  tokenExpiresAt  DateTime?
  user            User           @relation(fields: [userId], references: [id])
  slots           ProposedSlot[]
}

model ProposedSlot {
  id                   String             @id @default(cuid())
  appointmentRequestId String
  from                 DateTime
  to                   DateTime
  tatoueurId           String?
  status               String             @default("PENDING")
  selectedAt           DateTime?
  createdAt            DateTime           @default(now())
  appointmentRequest   AppointmentRequest @relation(fields: [appointmentRequestId], references: [id])

  @@index([appointmentRequestId])
}

model TimeSlot {
  id            String       @id @default(cuid())
  date          DateTime
  startTime     DateTime
  endTime       DateTime
  isAvailable   Boolean      @default(true)
  userId        String
  appointmentId String?
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  user          User         @relation(fields: [userId], references: [id])
}

model Client {
  id                 String               @id @default(cuid())
  userId             String
  firstName          String
  lastName           String
  email              String
  phone              String
  birthDate          DateTime?
  address            String?
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  aftercareRecords   Aftercare[]
  appointments       Appointment[]
  user               User                 @relation(fields: [userId], references: [id])
  FollowUpSubmission FollowUpSubmission[]
  medicalHistory     MedicalHistory?
  tattooDetails      TattooDetail[]
  tattooHistory      TattooHistory[]

  @@unique([userId, email])
}

model TattooDetail {
  id             String       @id @default(cuid())
  clientId       String?
  appointmentId  String?      @unique
  description    String
  zone           String?
  size           String?
  colorStyle     String?
  reference      String?
  sketch         String?
  piercingZone    PiercingZone?
  piercingZoneOreille PiercingZoneOreille?
  piercingZoneVisage  PiercingZoneVisage?
  piercingZoneBouche  PiercingZoneBouche?
  piercingZoneCorps   PiercingZoneCorps?
  piercingZoneMicrodermal PiercingZoneMicrodermal?
  estimatedPrice Float?
  price          Float?
  isPayed        Boolean      @default(false)
  appointment    Appointment? @relation(fields: [appointmentId], references: [id])
  client         Client?      @relation(fields: [clientId], references: [id])
}


model MedicalHistory {
  id            String  @id @default(cuid())
  clientId      String  @unique
  allergies     String?
  healthIssues  String?
  medications   String?
  pregnancy     Boolean
  tattooHistory String?
  client        Client  @relation(fields: [clientId], references: [id])
}

model TattooHistory {
  id           String    @id @default(cuid())
  clientId     String
  date         DateTime
  description  String?
  inkUsed      String?
  healingTime  String?
  careProducts String?
  photo        String?
  price        Float?
  size         String?
  tatoueurId   String?
  zone         String?
  client       Client    @relation(fields: [clientId], references: [id])
  tatoueur     Tatoueur? @relation(fields: [tatoueurId], references: [id])
}

model Aftercare {
  id                 String   @id @default(cuid())
  clientId           String
  submittedAt        DateTime @default(now())
  photoUrl           String?
  comment            String?
  approved           Boolean  @default(false)
  visibleInPortfolio Boolean  @default(false)
  client             Client   @relation(fields: [clientId], references: [id])
}

model Portfolio {
  id          String    @id @default(cuid())
  userId      String
  title       String
  description String?
  imageUrl    String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  tatoueurId  String?
  tatoueur    Tatoueur? @relation(fields: [tatoueurId], references: [id])
  user        User      @relation(fields: [userId], references: [id])
}

model ProductSalon {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?
  price       Float
  imageUrl    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  user        User     @relation(fields: [userId], references: [id])
}

model StockItem {
  id           String   @id @default(cuid())
  name         String
  category     String?  // "Encre", "Aiguille", "Gant", etc.
  quantity     Int      @default(0)
  unit         String?  // "bouteilles", "boîtes", "pièces", etc.
  minQuantity  Int?     // pour déclencher une alerte
  updatedAt    DateTime @updatedAt
  createdAt    DateTime @default(now())

  user        User      @relation(fields: [userId], references: [id])
  userId      String
}

model FollowUpRequest {
  id            String              @id @default(cuid())
  appointmentId String              @unique
  token         String              @unique
  status        FollowUpStatus      @default(PENDING)
  sentAt        DateTime?
  expiresAt     DateTime?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  submissionId  String?             @unique
  userId        String
  appointment   Appointment         @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  submission    FollowUpSubmission? @relation(fields: [submissionId], references: [id])
  user          User                @relation(fields: [userId], references: [id])

  @@index([status])
  @@index([createdAt])
  @@index([userId])
}

model FollowUpSubmission {
  id              String           @id @default(cuid())
  appointmentId   String           @unique
  clientId        String?
  rating          Int
  review          String?
  photoUrl        String
  isAnswered      Boolean          @default(false)
  response        String?
  isPhotoPublic   Boolean          @default(false)
  createdAt       DateTime         @default(now())
  userId          String
  followUpRequest FollowUpRequest?
  appointment     Appointment      @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  client          Client?          @relation(fields: [clientId], references: [id])
  user            User             @relation(fields: [userId], references: [id])

  @@index([createdAt])
  @@index([userId])
}

model SaasPlanDetails {
  id                 String         @id @default(cuid())
  userId             String         @unique
  currentPlan        SaasPlan       @default(FREE)
  planStatus         SaasPlanStatus @default(ACTIVE)
  startDate          DateTime       @default(now())
  endDate            DateTime?
  trialEndDate       DateTime?
  maxAppointments    Int            @default(30)
  maxClients         Int            @default(50)
  maxTattooeurs      Int            @default(1)
  maxPortfolioImages Int            @default(5)
  hasAdvancedStats   Boolean        @default(false)
  hasEmailReminders  Boolean        @default(false)
  hasCustomBranding  Boolean        @default(false)
  hasApiAccess       Boolean        @default(false)
  monthlyPrice       Float?
  yearlyPrice        Float?
  lastPaymentDate    DateTime?
  nextPaymentDate    DateTime?
  paymentMethod      String?
  stripeCustomerId   String?
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  user               User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([currentPlan])
  @@index([planStatus])
  @@index([endDate])
}

model RescheduleRequest {
  id            String           @id @default(cuid())
  appointmentId String
  token         String           @unique
  reason        String?
  newTatoueurId String?
  status        RescheduleStatus @default(PENDING)
  clientMessage String?
  expiresAt     DateTime
  processedAt   DateTime?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  appointment   Appointment      @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  newTatoueur   Tatoueur?        @relation(fields: [newTatoueurId], references: [id])

  @@index([token])
  @@index([appointmentId])
  @@index([status])
  @@index([expiresAt])
}

model PiercingPrice {
  id               String          @id @default(cuid())
  userId           String
  piercingZone     PiercingZone
  isActive         Boolean         @default(true)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  
  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  services         PiercingServicePrice[]
  
  @@unique([userId, piercingZone])
  @@index([userId])
  @@index([piercingZone])
}

model PiercingServicePrice {
  id               String          @id @default(cuid())
  userId           String
  piercingPriceId  String
  piercingZoneOreille  PiercingZoneOreille?
  piercingZoneVisage   PiercingZoneVisage?
  piercingZoneBouche   PiercingZoneBouche?
  piercingZoneCorps    PiercingZoneCorps?
  piercingZoneMicrodermal PiercingZoneMicrodermal?
  price            Float
  description      String?
  isActive         Boolean         @default(true)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  
  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  piercingPrice    PiercingPrice   @relation(fields: [piercingPriceId], references: [id], onDelete: Cascade)
  
  @@unique([piercingPriceId, piercingZoneOreille, piercingZoneVisage, piercingZoneBouche, piercingZoneCorps, piercingZoneMicrodermal])
  @@index([userId])
  @@index([piercingPriceId])
}

enum Role {
  admin
  user
}

enum SaasPlan {
  FREE
  PRO
  BUSINESS
}

enum SaasPlanStatus {
  ACTIVE
  EXPIRED
  CANCELED
  TRIAL
}

enum PrestationType {
  TATTOO
  PIERCING
  RETOUCHE
  PROJET
}

enum PiercingZone {
  OREILLE
  VISAGE
  BOUCHE
  CORPS
  MICRODERMAL
}

enum PiercingZoneOreille {
  LOBE
  LOBE_x2
  HELIX
  ANTI_HELIX
  ROOK 
  TRAGUS
  ANTI_TRAGUS
  CONCH
  FLAT 
  DAITH
  SNUG
  INDUSTRIEL
  STRETCH
  SURFACE_TRAGUS
  CARTILAGE_PUNCH
}

enum PiercingZoneVisage {
  NOSTRIL_FAKE_RING
  NOSTRIL_FAKE_RING_x2
  NOSTRIL_CLASSIQUE
  NOSTRIL_CLASSIQUE_x2
  HIGH_NOSTRIL
  HIGH_NOSTRIL_x2
  SEPTUM
  ARCADE
  CHEEK
  CHEEK_x2
  BRIDGE
}

enum PiercingZoneBouche {
  SMILEY
  MEDUSA
  LABRET
  JESTRUM
  LABRET_VERTICAL
  LABRET_DECALE
  DAHLIA
  LANGUE
  LANGUE_VENUM
  ANGEL_BITES
  SNAKE_BITES
  ANGEL_FANGS
  CYBER_BITES
  ASHLEY
}

enum PiercingZoneCorps {
  NOMBRIL
  TETON
  TETON_x2
}

enum PiercingZoneMicrodermal {
  SURFACE
  MICRODERMAL
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  DECLINED
  CANCELED
  RESCHEDULING
  NO_SHOW
  COMPLETED
}

enum FollowUpStatus {
  PENDING
  SUBMITTED
  EXPIRED
}

enum RescheduleStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
}
