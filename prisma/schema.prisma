// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

//! USER
enum Role {
  admin
  user
}

enum SaasPlan {
  FREE
  PRO
  BUSINESS
}

enum SaasPlanStatus {
  ACTIVE
  EXPIRED
  CANCELED
  TRIAL
}

// Le user est le SALON
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  emailVerified DateTime?
  password      String
  firstName     String?
  lastName      String?
  salonName     String?
  image         String?
  phone         String?
  address       String?
  city          String?
  postalCode    String?
  instagram     String?
  website       String?
  facebook      String?
  tiktok        String?
  description   String?
  salonHours    String?
  salonPhotos   String[]
  saasPlan      SaasPlan  @default(FREE)
  saasPlanUntil DateTime? // Date jusqu'√† laquelle le plan est actif
  role          Role      @default(user)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  appointments Appointment[]
  Tatoueur     Tatoueur[]
  Client       Client[]

  TimeSlot TimeSlot[]

  Portfolio Portfolio[]

  ProductSalon ProductSalon[]

  FollowUpRequest    FollowUpRequest[]
  FollowUpSubmission FollowUpSubmission[]
  
  // Relation avec les d√©tails du plan SaaS
  saasPlanDetails SaasPlanDetails?
}

model VerificationToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token], name: "email_token")
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String
  token   String   @unique
  expires DateTime

  @@unique([email, token], name: "email_token")
}

//! SALON
model Tatoueur {
  id          String   @id @default(cuid())
  name        String
  hours       String?
  user        User     @relation(fields: [userId], references: [id])
  userId      String // salon qui poss√®de ce tatoueur
  img         String?
  description String?
  phone       String?
  instagram   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  appointments Appointment[]

  Portfolio Portfolio[]
}

//! AGENDA ET RDV
enum PrestationType {
  TATTOO
  PIERCING
  RETOUCHE
  PROJET
}

enum AppointmentStatus {
  PENDING
  CONFIRMED
  DECLINED
  CANCELED
}

model Appointment {
  id         String            @id @default(cuid())
  title      String
  prestation PrestationType
  start      DateTime
  end        DateTime
  allDay     Boolean           @default(false)
  status     AppointmentStatus @default(PENDING)
  isPayed    Boolean           @default(false)

  // Relation avec User (nouvelle relation)
  user   User   @relation(fields: [userId], references: [id])
  userId String // ID du salon propri√©taire du rendez-vous

  tatoueur   Tatoueur? @relation(fields: [tatoueurId], references: [id])
  tatoueurId String?

  client   Client? @relation(fields: [clientId], references: [id])
  clientId String?

  //  Lien direct vers un TattooDetail pour les projets
  tattooDetail   TattooDetail?
  tattooDetailId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  TimeSlot TimeSlot[]

  FollowUpRequest FollowUpRequest[]

  FollowUpSubmission FollowUpSubmission[]
}

model TimeSlot {
  id          String   @id @default(cuid())
  date        DateTime // Date du cr√©neau
  startTime   DateTime // Heure de d√©but du cr√©neau
  endTime     DateTime // Heure de fin du cr√©neau
  isAvailable Boolean  @default(true)

  userId String
  user   User   @relation(fields: [userId], references: [id])

  appointment   Appointment? @relation(fields: [appointmentId], references: [id])
  appointmentId String? // Li√© si ce cr√©neau a √©t√© r√©serv√©

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//! CLIENT & FICHE CLIENT
model Client {
  id     String @id @default(cuid())
  userId String // Salon propri√©taire de la fiche client
  user   User   @relation(fields: [userId], references: [id])

  firstName String
  lastName  String
  email     String
  phone     String
  birthDate DateTime?
  address   String?

  // Lien vers les RDV (facultatif)
  appointments Appointment[] // üëà Un client peut avoir plusieurs RDV

  // Relations
  tattooDetail     TattooDetail?
  medicalHistory   MedicalHistory?
  tattooHistory    TattooHistory[]
  aftercareRecords Aftercare[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  FollowUpSubmission FollowUpSubmission[]

  @@unique([userId, email])
}

model TattooDetail {
  id String @id @default(cuid())

  // Soit li√© √† un client
  clientId String? @unique
  client   Client? @relation(fields: [clientId], references: [id])

  // Soit li√© √† un rendez-vous
  appointmentId String?      @unique
  appointment   Appointment? @relation(fields: [appointmentId], references: [id])

  description    String
  zone           String?
  size           String?
  colorStyle     String? // Noir & gris ou Couleur
  reference      String? // URL image du client
  sketch         String? // URL du croquis
  estimatedPrice Float?
  price          Float?
  isPayed        Boolean @default(false)

  @@unique([clientId, appointmentId])
}

model MedicalHistory {
  id       String @id @default(cuid())
  clientId String @unique
  client   Client @relation(fields: [clientId], references: [id])

  allergies     String?
  healthIssues  String?
  medications   String?
  pregnancy     Boolean
  tattooHistory String? // Commentaire sur anciens tatouages
}

model TattooHistory {
  id       String @id @default(cuid())
  clientId String
  client   Client @relation(fields: [clientId], references: [id])

  date         DateTime
  description  String
  beforeImage  String? // URL
  afterImage   String? // URL
  inkUsed      String?
  healingTime  String?
  careProducts String?
}

model Aftercare {
  id       String @id @default(cuid())
  clientId String
  client   Client @relation(fields: [clientId], references: [id])

  submittedAt        DateTime @default(now())
  photoUrl           String?
  comment            String?
  approved           Boolean  @default(false)
  visibleInPortfolio Boolean  @default(false)
}

//! PORTFOLIO & PRODUITS
model Portfolio {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  title       String
  description String?
  imageUrl    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Lien vers les tatoueurs si n√©cessaire
  tatoueurId String?
  tatoueur   Tatoueur? @relation(fields: [tatoueurId], references: [id])
}

model ProductSalon {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  name        String
  description String?
  price       Float
  imageUrl    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

// //! SALON SETTINGS
// model SalonSettings {
//   id                      String   @id @default(cuid())
//   salonName               String
//   autoConfirmationEnabled Boolean  @default(false)
//   createdAt               DateTime @default(now())
// }

// ----------------------
// SUIVI POST-RDV
// ----------------------
enum FollowUpStatus {
  PENDING
  SUBMITTED
  EXPIRED
}

model FollowUpRequest {
  id            String         @id @default(cuid())
  appointmentId String         @unique
  token         String         @unique
  status        FollowUpStatus @default(PENDING)
  sentAt        DateTime?
  expiresAt     DateTime?
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  submissionId  String?        @unique
  userId        String         // Salon propri√©taire

  appointment  Appointment         @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  submission   FollowUpSubmission? @relation(fields: [submissionId], references: [id])
  user         User                @relation(fields: [userId], references: [id])

  @@index([status])
  @@index([createdAt])
  @@index([userId])
}

model FollowUpSubmission {
  id            String   @id @default(cuid())
  appointmentId String   @unique
  clientId      String?
  rating        Int
  review        String?
  photoUrl      String
  isAnswered    Boolean @default(false)
  response      String?
  isPhotoPublic Boolean @default(false)
  createdAt     DateTime @default(now())
  userId        String   // Salon propri√©taire

  appointment     Appointment      @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  client          Client?          @relation(fields: [clientId], references: [id])
  followUpRequest FollowUpRequest?
  user            User             @relation(fields: [userId], references: [id])

  @@index([createdAt])
  @@index([userId])
}

// ----------------------
// D√âTAILS PLAN SAAS
// ----------------------
model SaasPlanDetails {
  id     String @id @default(cuid())
  userId String @unique

  // Plan actuel
  currentPlan   SaasPlan       @default(FREE)
  planStatus    SaasPlanStatus @default(ACTIVE)
  startDate     DateTime       @default(now())
  endDate       DateTime? // Null = illimit√©
  trialEndDate  DateTime? // Date fin d'essai
  
  // Limites du plan (FREE par d√©faut)
  maxAppointments    Int  @default(30)   // FREE: 30, PRO: 150, BUSINESS: -1 (illimit√©)
  maxClients         Int  @default(50)   // FREE: 50, PRO: 300, BUSINESS: -1 (illimit√©)
  maxTattooeurs      Int  @default(1)    // FREE: 1, PRO: 5, BUSINESS: -1 (illimit√©)
  maxPortfolioImages Int  @default(5)    // FREE: 5, PRO: 50, BUSINESS: -1 (illimit√©)

  // Fonctionnalit√©s
  hasAdvancedStats   Boolean @default(false) // Statistiques avanc√©es
  hasEmailReminders  Boolean @default(false) // Rappels email
  hasCustomBranding  Boolean @default(false) // Marque personnalis√©e
  hasApiAccess       Boolean @default(false) // Acc√®s API
  
  // Facturation
  monthlyPrice       Float?   // Prix mensuel
  yearlyPrice        Float?   // Prix annuel
  lastPaymentDate    DateTime?
  nextPaymentDate    DateTime?
  paymentMethod      String?  // 'stripe', 'paypal', etc.
  stripeCustomerId   String?  // ID client Stripe
  
  // M√©tadonn√©es
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([currentPlan])
  @@index([planStatus])
  @@index([endDate])
}
